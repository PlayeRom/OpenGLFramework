<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2"/>
<TITLE>OpenGLFramework - CTextureLoader</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF" text="#000000">

<H1>Klasa CTextureLoader</H1>

<p><b>Konstruktor</b></p>
<p><a href="#konstruktor">CTextureLoader</a></p>

<p><b>Metody klasy - interface</b></p>
<table border="1">
<tr><td><a href="#LoadAllTexture">LoadAllTexture</a></td></tr>
<tr><td><a href="#SetTexture">SetTexture</a></td></tr>
<tr><td><a href="#SetMultiTextures">SetMultiTextures</a></td></tr>
<tr><td><a href="#LoadTextureMipmaps">LoadTextureMipmaps</a></td></tr>
<tr><td><a href="#LoadTexture">LoadTexture</a></td></tr>
<tr><td><a href="#LoadTextureLowQuality">LoadTextureLowQuality</a></td></tr>
<tr><td><a href="#LoadMultiTextureMaskMipmaps">LoadMultiTextureMaskMipmaps</a></td></tr>
<tr><td><a href="#LoadEmbossBump">LoadEmbossBump</a></td></tr>
<tr><td><a href="#DisplayIDTextureName">DisplayIDTextureName</a></td></tr>
<tr><td><a href="#GetCountIndex">GetCountIndex</a></td></tr>
</table>

<p><b>Metody klasy - prywatne</b></p>
<table border="1">
<tr><td><a href="#CheckExtension">CheckExtension</a></td></tr>
<tr><td><a href="#LoadBMP">LoadBMP</a></td></tr>
<tr><td><a href="#LoadTGA">LoadTGA</a></td></tr>
<tr><td><a href="#LoadGLTexture">LoadGLTexture</a></td></tr>
<tr><td><a href="#LoadGLMultiTextureMask">LoadGLMultiTextureMask</a></td></tr>
<tr><td><a href="#CreateEmbossBumpTexture">CreateEmbossBumpTexture</a></td></tr>
</table>

<p><a href="#przyklad">Przyk³ad</a></p>

<p><a name="konstruktor"></a></p>

<hr/>

<h3>CTextureLoader::CTextureLoader</h3>
<p>[public] <b>CTextureLoader(const CGameControl *</b><i>objGameCtrl</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<i>objGameCtrl</i> - wska¼nik na obiekt klasy <a href="cgamecontrol.html">CGameControl</a>. Nale¿y wykorzystaæ globalny <a href="cgamecontrol.html">CGameControl</a> *g_objGameCtrl.
</p>

<p><a name="LoadAllTexture"></a></p>

<hr/>

<h3>CTextureLoader::LoadAllTexture</h3>
<p>[public] <b>GLboolean LoadAllTexture();</b></p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE w przypadku powodzenie wczytania plików.</p>
<p><b>Uwagi</b></p>
<p>Funkcja ta jest ju¿ wywo³ywana w
<a href="cgamecontrol.html#Initialization">CGameControl::Initialization</a> a my
tylko musimy wewn±trz jej dopisaæ odpowiednie instrukcje wczytuj±ce
pojedyncze pliki. Dokonamy tego za pomoc± funkcji
<a href="#LoadTextureMipmaps">LoadTextureMipmaps</a>,
<a href="#LoadTexture">LoadTexture</a> oraz
<a href="#LoadTextureLowQuality">LoadTextureLowQuality</a>.</p>

<p><a name="SetTexture"></a></p>

<hr/>

<h3>CTextureLoader::SetTexture</h3>
<p>Funkcja aktywuj±ca wcze¶niej wczytan± teksturê.</p>
<p>[public] <b>GLboolean SetTexture(GLuint </b><i>uiIndex</i><b> = 0);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>uiIndex</i></td></tr>
<tr><td></td><td>Indeks tekstury, któr± chcemy uaktywniæ. Indeksy liczone
s± od 0 w kolejno¶ci wczytywania tekstur.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE w przypadku powodzenia, GL_FALSE gdy podamy b³êdny indeks.</p>
<p><b>Uwagi</b></p>
<p>Funkcja SetTexture jednocze¶nie aktywuje teksturowanie poprzez wywo³anie
glEnable(GL_TEXTURE_2D).</p>

<p><a name="SetMultiTextures"></a></p>

<hr/>

<h3>CTextureLoader::SetMultiTextures</h3>
<p>Funkcja aktywuj±ca wcze¶niej wczytan± teksturê poprzez metodê CTextureLoader::LoadMultiTextureMaskMipmaps().</p>
<p>[public] <b>GLboolean SetMultiTextures(GLuint </b><i>uiIndex</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>uiIndex</i></td></tr>
<tr><td></td><td>Indeks tekstury, któr± chcemy uaktywniæ. Indeksy liczone
s± od 0 w kolejno¶ci wczytywania tekstur.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE w przypadku powodzenia, GL_FALSE gdy podamy b³êdny indeks.</p>
<p><b>Uwagi</b></p>
<p>Funkcja SetMultiTextures jednocze¶nie aktywuje teksturowanie poprzez wywo³anie
glEnable(GL_TEXTURE_2D).</p>

<p><a name="LoadTextureMipmaps"></a></p>

<hr/>

<h3>CTextureLoader::LoadTextureMipmaps</h3>
<p>Za pomoc± tej funkcji tworzymy teksturê mipmapow±.</p>
<p>[public] <b>GLboolean LoadTextureMipmaps(LPCTSTR </b><i>lpFileName</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>lpFileName</i></td></tr>
<tr><td></td><td>Pe³na nazwa pliku (wraz ze ¶cie¿k±), który chcemy uczyniæ tekstur±.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE w przypadku powodzenia, stworzenia tekstury.</p>

<p><a name="LoadTexture"></a></p>

<hr/>

<h3>CTextureLoader::LoadTexture</h3>
<p>Za pomoc± tej funkcji tworzymy teksturê typu linear.</p>
<p>[public] <b>GLboolean LoadTexture(LPCTSTR </b><i>lpFileName</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>lpFileName</i></td></tr>
<tr><td></td><td>Pe³na nazwa pliku (wraz ze ¶cie¿k±), który chcemy uczyniæ tekstur±.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE w przypadku powodzenia, stworzenia tekstury.</p>

<p><a name="LoadTextureLowQuality"></a></p>

<hr/>

<h3>CTextureLoader::LoadTextureLowQuality</h3>
<p>Za pomoc± tej funkcji tworzymy teksturê typu nearest.</p>
<p>[public] <b>GLboolean LoadTextureLowQuality(LPCTSTR </b><i>lpFileName</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>lpFileName</i></td></tr>
<tr><td></td><td>Pe³na nazwa pliku (wraz ze ¶cie¿k±), który chcemy uczyniæ tekstur±.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE w przypadku powodzenia, stworzenia tekstury.</p>

<p><a name="LoadMultiTextureMaskMipmaps"></a></p>

<hr/>

<h3>CTextureLoader::LoadMultiTextureMaskMipmaps</h3>
<p>Za pomoc± tej funkcji tworzymy teksturê o nieregularnym kszta³cie poprzez
u¿ycie dodatkowej tekstury jako maski.</p>
<p>[public] <b>GLboolean LoadMultiTextureMaskMipmaps(LPCTSTR </b><i>lpFileNameMask</i><b>, LPCTSTR </b><i>lpFileNameRGB</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>lpFileNameMask</i></td></tr>
<tr><td></td><td>Pe³na nazwa pliku z mask±, który chcemy uczyniæ tekstur±.</td></tr>

<tr><td><i>lpFileNameRGB</i></td></tr>
<tr><td></td><td>Pe³na nazwa pliku z normaln±, kolorow± tekstur±.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE w przypadku powodzenia, stworzenia tekstury. W przeciwnym wypadku GL_FALSE.</p>
<p><b>Uwagi</b></p>
<p>Jest to pseudo-multiteksturing, który mo¿emy wykorzystaæ przy sprite'ach z u¿yciem
specjalnej maski do wskazania obszarów tekstury, które maj± byæ niewidoczne.
Dziêki temu w wydajny sposób (rysuj±c obiekt tylko jeden raz) mo¿emy uzyskaæ
dowolne kszta³ty sprite'a. Metoda ta polega na wczytaniu dwóch tekstur,
gdzie pierwsza to tzw. maska - czyli tekstura w odcieniach szaro¶ci, gdzie
czarny kolor oznacza ca³kowit± przezroczysto¶æ a bia³y ca³kowit± widoczno¶æ
elementów drugiej tekstury. Druga tekstura to w³a¶ciwy, w pe³ni kolorowy obraz.
Nastêpnie program spreparuje obydwie tekstury do jednej, któr± mo¿emy wykorzystaæ.<br />
Nale¿y pamiêtaæ, ¿e pomimo podania dwóch plików, powy¿sza funkcja utworzy jedn± teksturê
czyli zostanie utworzony jeden indeks tekstury - pamiêtajmy o tym przy wywo³ywaniu
CTextureLoader::SetMultiTextures(). Poza tym, jak wynika z nazwy powy¿szej
funkcji, tekstury zawsze bêd± mipmapami.</p>

<p><a name="LoadEmbossBump"></a></p>

<hr/>

<h3>CTextureLoader::LoadEmbossBump</h3>
<p>Za pomoc± tej funkcji tworzymy dwie tekstury, które zostan± wykorzytsane
dla efektu mapowania wybojów.</p>
<p>[public] <b>GLboolean LoadEmbossBump(LPCTSTR </b><i>lpFileName</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>lpFileName</i></td></tr>
<tr><td></td><td>Nazwa pliku, któr± chcemy uczyæ tekstur±. Musi to byæ
specjakna tekstura, tzw. mapa wysoko¶ci, gdzie ciemne obszary oznaczaj±
elementy ni¿ej po³o¿one, a ja¶niejsze wy¿ej.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE w przypadku powodzenia, stworzenia tekstury. W przeciwnym wypadku GL_FALSE.</p>
<p><b>Uwagi</b></p>
<p>Nale¿y pamiêtaæ, ¿e powy¿sza metoda z jednego pliku tworzy dwie tekstuty,
a wiêc powstaj± dwa indeksy tekstur. W programie, przy wykorzytywaniu tekstury
bump, u¿ywaæ bêdziemy tylko indeksu pierwszego.</p>

<p><a name="DisplayIDTextureName"></a></p>

<hr/>

<h3>CTextureLoader::DisplayIDTextureName</h3>
<p>Funkcja wypisuj±ca na konsolê nazwy plików-tekstur wraz z ich identyfikatorami.</p>
<p>[public] <b>GLvoid DisplayIDTextureName();</b></p>

<p><a name="GetCountIndex"></a></p>

<hr/>

<h3>CTextureLoader::GetCountIndex</h3>
<p>Dziêki tej metodzie dowiemy siê ile mamy indeksów tekstur.</p>
<p>[public] <b>GLint GetCountIndex();</b></p>
<p><b>Warto¶æ zwracana</b></p>
<p>Liczba ca³kowita informuj±ca o ilo¶æ indeksów.</p>

<p><a name="CheckExtension"></a></p>

<hr/>

<h3>CTextureLoader::CheckExtension</h3>
<p>Funkcja sprawdzaj±ca rozszerzenie pliku.</p>
<p>[private] <b>GLint CheckExtension(LPCTSTR </b><i>lpFileName</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>lpFileName</i></td></tr>
<tr><td></td><td>Nazwa pliku.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>0 gdy plik jest BMP, 1 gdy plik jest TGA, w przypadku b³êdu lub nieobs³ugiwanego formatu -1.</p>

<p><a name="LoadBMP"></a></p>

<hr/>

<h3>CTextureLoader::LoadBMP</h3>
<p>Funkcja wczytuj±ca plik BMP.</p>
<p>[private] <b>AUX_RGBImageRec* LoadBMP(LPCTSTR </b><i>lpFileName</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>lpFileName</i></td></tr>
<tr><td></td><td>Nazwa pliku.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>W przypadku powodzenia wska¼nik na strukturê AUX_RGBImageRec. W przypadku b³êdu NULL.</p>

<p><a name="LoadTGA"></a></p>

<hr/>

<h3>CTextureLoader::LoadTGA</h3>
<p>Funkcja wczytuj±ca plik TGA.</p>
<p>[private] <b>GLboolean LoadTGA(STexture &amp;</b><i>ptexTexture</i><b>, LPCTSTR </b><i>lpFileName</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>ptexTexture</i></td></tr>
<tr><td></td><td>Referencja na strukturê STexture.</td></tr>

<tr><td><i>lpFileName</i></td></tr>
<tr><td></td><td>Nazwa pliku.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE gdy wczytanie zakoñczy siê powodzeniem, w przeciwnym wypadku GL_FALSE.</p>

<p><a name="LoadGLTexture"></a></p>

<hr/>

<h3>CTextureLoader::LoadGLTexture</h3>
<p>G³ówna funkcja tworz±ca teksturê.</p>
<p>[private] <b>GLboolean LoadGLTexture(LPCTSTR </b><i>lpFileName</i><b>, GLint </b><i>iMode</i><b> = 0, GLint </b><i>iFormat</i><b> = 0, GLboolean </b><i>bEmbossBump</i><b> = GL_FALSE);</b></p>
<p><b>Parametry</b></p>
<p>

<table border="0">
<tr><td><i>lpFileName</i></td></tr>
<tr><td></td><td>Nazwa pliku.</td></tr>

<tr><td><i>iMode</i></td></tr>
<tr><td></td><td>Typ tekstury jak± chcemy stworzyæ:<br />
&nbsp;&nbsp;&nbsp;&nbsp;0 - tekstura mipmapowa<br />
&nbsp;&nbsp;&nbsp;&nbsp;1 - tekstura typu linear<br />
&nbsp;&nbsp;&nbsp;&nbsp;2 - tekstura typu nearest<br />
</td></tr>

<tr><td><i>iFormat</i></td></tr>
<tr><td></td><td>Format pliku, mo¿emy podaæ:<br />
&nbsp;&nbsp;&nbsp;&nbsp;0 - plik BMP<br />
&nbsp;&nbsp;&nbsp;&nbsp;1 - plik TGA<br />
</td></tr>

<tr><td><i>bEmbossBump</i></td></tr>
<tr><td></td><td>Czy tekstura jest map± wysoko¶ci dla efektu mapowania wybojów.</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE gdy wczytanie zakoñczy siê powodzeniem, w przeciwnym wypadku GL_FALSE.</p>

<p><a name="LoadGLMultiTextureMask"></a></p>

<hr/>

<h3>CTextureLoader::LoadGLMultiTextureMask</h3>
<p>Metoda tworz±ca teksturê z pseudo-multiteksturingiem.</p>
<p>[private] <b>GLboolean LoadGLMultiTextureMask(LPCTSTR </b><i>lpFileName1</i><b>, LPCTSTR </b><i>lpFileName2</i><b>, GLint </b><i>iMode</i><b> = 0, GLint </b><i>iFormat1</i><b> = 0, GLint </b><i>iFormat2</i><b> = 0);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>lpFileName1</i></td></tr>
<tr><td></td><td>Nazwa pliku z mask±.</td></tr>

<tr><td><i>lpFileName2</i></td></tr>
<tr><td></td><td>Nazwa pliku z tekstur± kolorow±.</td></tr>

<tr><td><i>iMode</i></td></tr>
<tr><td></td><td>Typ tekstury jak± chcemy stworzyæ:<br />
&nbsp;&nbsp;&nbsp;&nbsp;0 - tekstura mipmapowa<br />
&nbsp;&nbsp;&nbsp;&nbsp;1 - tekstura typu linear<br />
&nbsp;&nbsp;&nbsp;&nbsp;2 - tekstura typu nearest
</td></tr>

<tr><td><i>iFormat1</i></td></tr>
<tr><td></td><td>Format pliku z mask±, mo¿emy podaæ:<br />
&nbsp;&nbsp;&nbsp;&nbsp;0 - plik BMP<br />
&nbsp;&nbsp;&nbsp;&nbsp;1 - plik TGA
</td></tr>

<tr><td><i>iFormat2</i></td></tr>
<tr><td></td><td>Format pliku z kolorem, mo¿emy podaæ:<br />
&nbsp;&nbsp;&nbsp;&nbsp;0 - plik BMP<br />
&nbsp;&nbsp;&nbsp;&nbsp;1 - plik TGA
</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE gdy wczytanie zakoñczy siê powodzeniem, w przeciwnym wypadku GL_FALSE.</p>
<p><b>Uwagi</b></p>
<p>Pomimo podania formatów dla ka¿dego z plików, funkcja obs³uguje jedynie format BMP.</p>

<p><a name="CreateEmbossBumpTexture"></a></p>

<hr/>

<h3>CTextureLoader::CreateEmbossBumpTexture</h3>
<p>Metoda tworz±ca tekstury dla efektu mapowania wybojów.</p>
<p>[private] <b>GLboolean CreateEmbossBumpTexture(GLint </b><i>iIndex</i><b>, STexture &amp;</b><i>texTexture</i><b>, GLint </b><i>iMode</i><b>);</b></p>
<p><b>Parametry</b></p>
<p>
<table border="0">
<tr><td><i>iIndex</i></td></tr>
<tr><td></td><td>Indeks tekstury.</td></tr>

<tr><td><i>texTexture</i></td></tr>
<tr><td></td><td>Adres do strukturt STexture zawieraj±cej dane wcze¶niej wczytego pliku.</td></tr>

<tr><td><i>iMode</i></td></tr>
<tr><td></td><td>Typ tekstury jak± chcemy stworzyæ:<br />
&nbsp;&nbsp;&nbsp;&nbsp;0 - tekstura mipmapowa<br />
&nbsp;&nbsp;&nbsp;&nbsp;1 - tekstura typu linear<br />
&nbsp;&nbsp;&nbsp;&nbsp;2 - tekstura typu nearest.
</td></tr>
</table>
</p>
<p><b>Warto¶æ zwracana</b></p>
<p>GL_TRUE gdy stworzenie tekstur zakoñczy siê powodzeniem, w przeciwnym wypadku GL_FALSE.</p>

<p><a name="przyklad"></a></p>

<hr/>
<h3>Przyk³ad</h3>
<p><font face="Courier New" size="2">
GLboolean CTextureLoader::LoadAllTexture()<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;...<br />
&nbsp;&nbsp;&nbsp;&nbsp;LoadTextureMipmaps(_T("textures/img1.bmp"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// index 0<br />
&nbsp;&nbsp;&nbsp;&nbsp;LoadTextureLowQuality(_T("textures/picture.bmp"));&nbsp;// index 1<br />
&nbsp;&nbsp;&nbsp;&nbsp;LoadTexture(_T("textures/graphic.bmp"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// index 2<br />
&nbsp;&nbsp;&nbsp;&nbsp;...<br />
&nbsp;&nbsp;&nbsp;&nbsp;return GL_TRUE;<br />
}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;...<br />
&nbsp;&nbsp;&nbsp;&nbsp;// gdzie¶ w kodzie uaktywniamy teksturê picture.bmp:<br />
&nbsp;&nbsp;&nbsp;&nbsp;m_objGameCtrl->GetTextureLoader()->SetTexture(1);<br />
</font></p>

<hr />
</BODY>
</HTML>